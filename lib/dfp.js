'use strict';

var nodeGoogleDfp = require('node-google-dfp');
var Bluebird = require('bluebird');
var path = require('path');
var _ = require('lodash');
var levelup = require('level');

var DfpUser = require('./user').DfpUser;

var CONCURRENCY = {
  concurrency: 1
};

/**
 * These leveldb stores are used to cache lookups to DFP so that anything that
 * has already been queried before does not require a call over the network. If
 * the cache becomes invalid, delete the directories created in local/
 */
var criteriaKeyPath = path.resolve(__dirname, '../local/criteriaKeyStore');
var criteriaValuePath = path.resolve(__dirname, '../local/criteriaValueStore');
var adUnitPath = path.resolve(__dirname, '../local/adUnitStore');
var orderPath = path.resolve(__dirname, '../local/orderStore');
var labelPath = path.resolve(__dirname, '../local/labelStore');

var criteriaKeyStore = levelup(criteriaKeyPath);
var criteriaValueStore = levelup(criteriaValuePath);
var adUnitStore = levelup(adUnitPath);
var orderStore = levelup(orderPath);
var labelStore = levelup(labelPath);

Bluebird.promisifyAll(criteriaKeyStore);
Bluebird.promisifyAll(criteriaValueStore);
Bluebird.promisifyAll(adUnitStore);
Bluebird.promisifyAll(orderStore);
Bluebird.promisifyAll(labelStore);

/**
 * Calling this constructor instantiates the client to the DFP api.
 * @class
 *
 * @param {Object} credentials  Credentials generated by DFP. Instructions in
 *                              the README.
 * @param {[type]} config       Configuration object. Instructions in the
 *                              README.
 * @param {[type]} refreshToken Refresh token to resume a session with DFP, as
 *                              opposed to obraining a new one. Instructions
 *                              in the README.
 */
function Dfp(credentials, config, refreshToken) {

  this.dfpUser = new DfpUser(
    config.networkCode,
    config.appName,
    config.version
  );

  this.dfpUser.setSettings({
    client_id: credentials.clientId,
    client_secret: credentials.clientSecret,
    refresh_token: refreshToken,
    redirect_url: credentials.redirectUrl,
  });
}

/**
 * Updates line items in DFP. Caution: archived line items cannot be updated and
 * attempting to do so will throw an error. It is best to filter out archived
 * line items before calling this method.
 *
 * @param  {Array} lineItems The line items with any updates already made.
 * @return {Array}           Updated line items. Should be the same as what was
 *                           passed it, with the addition of any fields created
 *                           by DFP
 */
Dfp.prototype.updateLineItems = function(lineItems) {
  var ctx = this;

  var input = {
    'lineItems': lineItems
  };

  return ctx.dfpUser.executeAPIFunction(
    'LineItemService',
    'updateLineItems',
    input
  );
};

/**
 * Updates creatives in DFP. Caution: archived creatives cannot be updated and
 * attempting to do so will throw an error. It is best to filter out archived
 * creatives before calling this method.
 *
 * @param  {Array} creatives The creatives with any updates already made.
 * @return {Array}           Updated creatives. Should be the same as what was
 *                           passed it, with the addition of any fields created
 *                           by DFP
 */
Dfp.prototype.updateCreatives = function(creatives) {
  var ctx = this;

  var input = {
    'creatives': creatives
  };

  return ctx.dfpUser.executeAPIFunction(
    'CreativeService',
    'updateCreatives',
    input
  );
};

/**
 * Extracts the results from a response passed in and throws an error if it does
 * not exist.
 * @param  {Object} response A response from the DFP API.
 * @return {Object}          The results.
 */
function extractResults(response) {
  if (!response.results) {
    throw new Error('Expected to find results, but there were none');
  } else {
    return response.results;
  }
}

function extractFirstId(results) {
  if (!results[0] || !result[0].id) {
    throw new Error('expected to find an id, but didnt');
  } else {
    return results[0].id
  }
}

/**
 * Queries DFP to get all line items that match the string passed in.
 *
 * @param  {String} name String used for querying. This string can include
 *                       wildcards and other special characters accepted by DFP.
 * @return {Array}       All matching line items found in DFP
 */
Dfp.prototype.getLineItems = function(name) {
  var ctx = this;
  var service = 'LineItemService';
  var method = 'getLineItemsByStatement';

  var query = "Where name like '" + name + "'";
  query = new nodeGoogleDfp.Statement(query);

  return ctx.dfpUser.executeAPIFunction(service, method, query)
    .then(extractResults);
};

/**
 * Gets the system assigned id of a given criteria key in DFP. Uses a local
 * store for caching.
 *
 * @param  {String} name String used for querying. This string can include
 *                       wildcards and other special characters accepted by DFP.
 * @return {String}      The system assigned id of the passed in key.
 */
Dfp.prototype.getCriteriaKey = function(name) {
  var ctx = this;
  var service = 'CustomTargetingService';
  var method = 'getCustomTargetingKeysByStatement';

  var query = "Where name like '" + name + "'";
  query = new nodeGoogleDfp.Statement(query);

  return criteriaKeyStore.getAsync(name)
    .catch(function() {
      // not found in store, look up instead
      return ctx.dfpUser.executeAPIFunction(service, method, query)
        .then(extractResults)
        .then(extractFirstId)
        .tap(function(id) {
          return criteriaKeyStore.putAsync(name, id)
            .catch(function(e) {
              console.log('locally storing criteria key failed', e);
              throw e;
            });
        })
    });
};

/**
 * Gets the system assigned id of a given criteria value in DFP. Uses a local
 * store for caching.
 *
 * @param  {String} name  String used for querying. This string can include
 *                        wildcards and other special characters accepted by DFP
 * @param  {String} keyId Limits search to values associated with this key.
 * @return {String}      The system assigned id of the passed in key.
 */
Dfp.prototype.getCriteriaValues = function(name, keyId) {
  var ctx = this;
  var service = 'CustomTargetingService';
  var method = 'getCustomTargetingValuesByStatement';

  var storeKey = keyId + ':' + name;

  return criteriaValueStore.getAsync(storeKey)
    .catch(function() {
      // not found in store, look up instead
      var query = "Where name like '";
      query += name;
      query += "' and customTargetingKeyId like '";
      query += keyId;
      query += "'";
      query = new nodeGoogleDfp.Statement(query);
      return ctx.dfpUser.executeAPIFunction(service, method, query)
        .then(extractResults)
        .map(function(result) {
          return criteriaValueStore.putAsync(storeKey, result.id);
        })
        .catch(function(e) {
          console.log('locally storing criteria value failed', e);
          throw e;
        });
      .then(function() {
        return criteriaValueStore.getAsync(storeKey);
      });
    })
    .then(function(id) {
      return [id];
    });
};

/**
 * Find the DFP ids of the key value pairs passed in.
 * @param  {Object} criteria The key value pairs to look up.
 * @return {Array}           Objects containing the ids of the keys and values
 *                           passed in.
 */
Dfp.prototype.getCriteria = function(criteria) {
  var ctx = this;

  return Bluebird.resolve(_.pairs(criteria))
    .map(function(pair) {
      return ctx.getCriteriaKey(pair[0])
        .then(function(key) {
          return Bluebird.resolve(pair[1])
            .then(function(value) {
              return ctx.getCriteriaValues(value, key);
            })
            .then(function(value) {
              return [key, value];
            });
        })
        .spread(function(keyId, valueIds) {
          return {
            keyId: keyId,
            valueIds: valueIds
          };
        });
    }, CONCURRENCY);
};

/**
 * Gets the system assigned id of the ad unit corresponding to the details
 * passed in. NOTE: the logic used to determine an ad unit name are specific to
 * Curiosity Media.
 *
 * @param  {Object} name Name given to the ad unit in DFP.
 * @return {String}      The id of the ad unit matching the details passed in.
 */
Dfp.prototype.getAdUnit = function(name) {
  var ctx = this;
  var service = 'InventoryService';
  var method = 'getAdUnitsByStatement';

  var query;
  query = "Where name like '" + name + "'";
  query = new nodeGoogleDfp.Statement(query);

  return adUnitStore.getAsync(name)
    .catch(function() {
      return ctx.dfpUser.executeAPIFunction(service, method, query)
        .then(extractResults)
        .then(extractFirstId)
        .tap(function(id) {
          return adUnitStore.putAsync(name, id);
        })
    });
};

/**
 * Find the DFP id of the order passed in.
 *
 * @param  {String} name The name of the order in DFP.
 * @return {String}      The id of the order corresponding to the name passed in
 */
Dfp.prototype.getOrder = function(name) {
  var ctx = this;
  var service = 'OrderService';
  var method = 'getOrdersByStatement';

  var query = "Where name like '" + name + "'";
  query = new nodeGoogleDfp.Statement(query);

  return orderStore.getAsync(name)
    .catch(function() {
      return ctx.dfpUser.executeAPIFunction(service, method, query)
        .then(extractResults)
        .then(extractFirstId)
        .tap(function(id) {
          return orderStore.putAsync(name, id)
        })
        .catch(function(e) {
          console.log('locally storing order failed', e);
          throw e;
        });
    });
}

/**
 * Modifies the line item passed in so that has the correct order id, ad unit
 * id, and criteria key and value ids, which are required in DFP. Prepares the
 * line item object for actually creating a line item in DFP.
 *
 * @param  {Object} lineItemParam Object representation of a line item.
 * @return {Object}               The original line item with additions. Ready
 *                                to be passed to the method for creating a line
 *                                item.
 */
Dfp.prototype.prepareLineItem = function(lineItemParam) {
  var ctx = this;

  // Make a clone so that the original parameters are not mutated.
  var lineItem = _.cloneDeep(lineItemParam);

  return ctx.getOrder(lineItem.orderName)
    .then(function(orderId) {
      lineItem.orderId = orderId;
      delete lineItem.orderName;
    })
    .then(function() {
      return ctx.getAdUnit(lineItem.adUnitName);
    })
    .then(function(adUnitId) {
      lineItem.targeting.inventoryTargeting.targetedAdUnits = [{
        adUnitId: adUnitId,
        includeDescendants: true
      }];
      delete lineItem.adUnitName;
    })
    .then(function() {
      return ctx.getCriteria(lineItem.customCriteriaKVPairs);
    })
    .then(function(criteria) {
      _.forEach(criteria, function(condition) {
        lineItem.targeting.customTargeting.children[0].children.push({
          "attributes": {
            "xsi:type": "CustomCriteria"
          },
          "keyId": condition.keyId,
          "valueIds": condition.valueIds,
          "operator": "IS"
        });
      });
      delete lineItem.customCriteriaKVPairs;
      return lineItem;
    });
};

/**
 * Creates a line item in DFP.
 *
 * @param  {Array} lineItems Line items to be created in DFP
 * @return {Object}          Response from the DFP api, containing the line
 *                           items if the creation succeeded or an error if
 *                           it failed.
 */
Dfp.prototype.createLineItems = function(lineItems) {
  var ctx = this;

  var service = 'LineItemService';
  var method = 'createLineItems';
  var input = {
    lineItems: lineItems
  };

  return ctx.dfpUser.executeAPIFunction(
    service,
    method,
    input
  );
};

/**
 * Find the DFP id of the advertiser passed in.
 *
 * @param  {String} name The name of the advertiser in DFP.
 * @return {String}      The id of the advertiser corresponding to the name
 *                       passed in.
 */
Dfp.prototype.getAdvertiser = function(name) {
  var ctx = this;
  var service = 'CompanyService';
  var method = 'getCompaniesByStatement';

  var query = "Where name like '" + name + "'";
  query = new nodeGoogleDfp.Statement(query);

  return ctx.dfpUser.executeAPIFunction(service, method, query)
    .then(extractResults)
    .then(extractFirstId);
};

/**
 * Gets the system assigned id of the label passed in. Uses a local store for
 * caching.
 *
 * @param  {String} name String used for querying. This string can include
 *                       wildcards and other special characters accepted by DFP.
 * @return {String}      The system assigned id of the passed in key.
 */
Dfp.prototype.getLabel = function(name) {
  var ctx = this;
  var service = 'LabelService';
  var method = 'getLabelsByStatement';

  var query = "Where name like '" + name + "'";
  query = new nodeGoogleDfp.Statement(query);

  return labelStore.getAsync(name)
    .catch(function() {
      return ctx.dfpUser.executeAPIFunction(service, method, query)
        .then(function(response) {
          return response.results[0].id;
        })
        .tap(function(id) {
          return labelStore.putAsync(name, id)
            .catch(function(e) {
              console.log('locally storing label failed', e);
              throw e;
            });
        });
    });
};

/**
 * Gets the full creative matching the name passed in.
 *
 * @param  {String} name String used for querying. This string can include
 *                       wildcards and other special characters accepted by DFP.
 * @return {String}      The system assigned id of the passed in key.
 */
Dfp.prototype.getCreatives = function(name) {
  var ctx = this;
  var service = 'CreativeService';
  var method = 'getCreativesByStatement';

  var query = "Where name like '" + name + "'";
  query = new nodeGoogleDfp.Statement(query);

  return ctx.dfpUser.executeAPIFunction(service, method, query)
    .then(extractResults);
};

/**
 * Creates a creatives in DFP.
 *
 * @param  {Array}  creativesParam Creatives to be created in DFP
 * @param  {String} partner        The name of the advertiser to associate this
 *                                 creative with.
 * @return {Object}                Response from the DFP api, containing the
 *                                 creatives if the creation succeeded or an
 *                                 error if it failed.
 */
Dfp.prototype.createCreatives = function(creativesParam, partner) {
  var ctx = this;
  var service = 'CreativeService';
  var method = 'createCreatives';

  var creatives = _.cloneDeep(creativesParam);

  return ctx.getAdvertiser(partner)
    .then(function(advertiserId) {
      creatives = _.map(creatives, function(creative) {
        creative.advertiserId = advertiserId;
        return creative;
      });
    })
    .then(function() {
      return ctx.dfpUser.executeAPIFunction(service, method, {
        creatives: creatives
      });
    });
};

/**
 * Creates an order in DFP.
 *
 * @param  {Object} order Order to be created in DFP
 * @return {Object}       Response from the DFP api, containing the order if the
 *                        creation succeeded or an error if it failed.
 */
Dfp.prototype.createOrder = function(order) {
  var ctx = this;
  return ctx.getAdvertiser(order.partner)
    .then(function(advertiserId) {
      order.advertiserId = advertiserId;
      delete order.partner;
      return order;
    })
    .then(function(newOrder) {
      var input = {
        orders: newOrder
      };

      return ctx.dfpUser.executeAPIFunction(
        'OrderService',
        'createOrders',
        input
      );
    });
};

/**
 * Creates a line item creative association in DFP.
 *
 * @param  {Object} associations The ids of the line item and creative to
 *                               create an association for
 * @return {Object}              Response from the DFP api, containing the
 *                               line item associations if the creation
 *                               succeeded or an error if it failed.
 */
Dfp.prototype.createAssociations = function(associations) {
  var ctx = this;

  var service = 'LineItemCreativeAssociationService';
  var method = 'createLineItemCreativeAssociations';
  var input = {
    lineItemCreativeAssociations: associations
  };

  return ctx.dfpUser.executeAPIFunction(
      service,
      method,
      input
    );
};

Dfp.prototype.updateAssociations = function(associations) {
  var ctx = this;

  var service = 'LineItemCreativeAssociationService';
  var method = 'updateLineItemCreativeAssociations';

  var input = {
    'lineItemCreativeAssociations': associations
  };

  return ctx.dfpUser.executeAPIFunction(
    service,
    method,
    input
  );
};

Dfp.prototype.getAssociations = function(query) {
  var ctx = this;

  var service = 'LineItemCreativeAssociationService';
  var method = 'getLineItemCreativeAssociationsByStatement';

  var statement = new nodeGoogleDfp.Statement(query);

  return ctx.dfpUser.executeAPIFunction(
    service,
    method,
    statement
  );
};

Dfp.prototype.runReportJob = function(reportJob) {
  var ctx = this;

  var service = 'ReportService';
  var method = 'runReportJob';
  var input = {
    reportJob: reportJob
  };

  return ctx.dfpUser.executeAPIFunction(
      service,
      method,
      input
    );
};

Dfp.prototype.getReportJobStatus = function(id) {
  var ctx = this;

  var service = 'ReportService';
  var method = 'getReportJobStatus';
  var input = {
    reportJobId: id
  };

  return ctx.dfpUser.executeAPIFunction(
      service,
      method,
      input
    );
};

Dfp.prototype.getReportDownloadURL = function(id, exportFormat) {
  var ctx = this;

  var service = 'ReportService';
  var method = 'getReportDownloadURL';
  var input = {
    reportJobId: id,
    exportFormat: exportFormat
  };

  return ctx.dfpUser.executeAPIFunction(
      service,
      method,
      input
    );
};

module.exports = Dfp;
